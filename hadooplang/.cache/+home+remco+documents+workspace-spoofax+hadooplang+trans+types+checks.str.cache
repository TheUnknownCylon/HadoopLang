Module("trans/types/checks",[Imports([Import("include/Hadooplang"),Import("lib/analysis-library.generated"),Import("lib/analysis-auto.generated"),Import("trans/index"),Import("trans/types/typeof"),Import("trans/lib/lists"),Import("trans/check"),Import("trans/types/operators"),Import("trans/types/operators")]),Rules([RDefT("typecheck",[],[DefaultVarDec("typetocheckfor")],RuleNoCond(Var("vartocheck"),App(CallNoArgs(SVar("equal")),NoAnnoList(Tuple([App(CallNoArgs(SVar("type")),App(CallNoArgs(SVar("type-of")),Var("vartocheck"))),Var("typetocheckfor")])))))]),Rules([RDefNoArgs("constraint-error",Rule(NoAnnoList(Op("DatasetSetVar",[Var("ref"),Var("expr")])),NoAnnoList(Tuple([Var("expr"),NoAnnoList(StringQuotation1("                                                           ",[QStr("Wrong type, expected "),StringEscape1("                                                                                ",Var("expected")),QStr(", got "),StringEscape1("                                                                                                ",Var("got")),QStr(".")]))])),Seq(Assign(Var("typeexpected"),App(CallNoArgs(SVar("type")),App(CallNoArgs(SVar("type-of")),Var("ref")))),Seq(Not(BA(CallT(SVar("typecheck"),[],[Var("typeexpected")]),Var("expr"))),Seq(Assign(Var("expected"),App(CallNoArgs(SVar("type-name")),Var("typeexpected"))),Assign(Var("got"),App(CallNoArgs(SVar("type-name")),App(CallNoArgs(SVar("type-of")),Var("expr")))))))))]),Rules([RDefNoArgs("constraint-error",Rule(As(Var("o"),NoAnnoList(Op("OpExp",[Var("op"),Var("a"),Var("b")]))),Var("errors"),Seq(Not(BA(CallNoArgs(SVar("type-of")),Var("o"))),LChoice(Assign(Var("errors"),App(CallNoArgs(SVar("constraint-error-op")),Var("o"))),Assign(Var("errors"),NoAnnoList(Tuple([Var("o"),NoAnnoList(StringQuotation1("                              ",[QStr("Operator has no support for types "),StringEscape1("                                                                ",App(CallNoArgs(SVar("type-name")),App(CallNoArgs(SVar("type-type-of")),Var("a")))),QStr(" and "),StringEscape1("                                                                                                  ",App(CallNoArgs(SVar("type-name")),App(CallNoArgs(SVar("type-type-of")),Var("b")))),QStr(".")]))]))))))),RDefNoArgs("constraint-error-op",RuleNoCond(NoAnnoList(Tuple([NoAnnoList(Op("OpPlus",[])),Var("x"),Var("y")])),App(CallT(SVar("validate_both_sides"),[],[NoAnnoList(List([NoAnnoList(Op("Num",[])),NoAnnoList(Op("String",[]))]))]),NoAnnoList(Tuple([Var("x"),Var("y")]))))),RDefNoArgs("constraint-error-op",RuleNoCond(NoAnnoList(Tuple([NoAnnoList(Op("OpTimes",[])),Var("x"),Var("y")])),App(CallT(SVar("validate_both_sides"),[],[NoAnnoList(Op("Num",[]))]),NoAnnoList(Tuple([Var("x"),Var("y")]))))),RDefNoArgs("constraint-error-op",RuleNoCond(NoAnnoList(Tuple([NoAnnoList(Op("OpMin",[])),Var("x"),Var("y")])),App(CallT(SVar("validate_both_sides"),[],[NoAnnoList(Op("Num",[]))]),NoAnnoList(Tuple([Var("x"),Var("y")]))))),RDefNoArgs("constraint-error-op",RuleNoCond(NoAnnoList(Tuple([NoAnnoList(Op("OpDivide",[])),Var("x"),Var("y")])),App(CallT(SVar("validate_both_sides"),[],[NoAnnoList(Op("Num",[]))]),NoAnnoList(Tuple([Var("x"),Var("y")]))))),RDefNoArgs("constraint-error-op",RuleNoCond(NoAnnoList(Tuple([NoAnnoList(Op("OpModulo",[])),Var("x"),Var("y")])),App(CallT(SVar("validate_both_sides"),[],[NoAnnoList(Op("Num",[]))]),NoAnnoList(Tuple([Var("x"),Var("y")]))))),RDefNoArgs("constraint-error-op",RuleNoCond(NoAnnoList(Tuple([NoAnnoList(Op("OpAnd",[])),Var("x"),Var("y")])),App(CallT(SVar("validate_both_sides"),[],[NoAnnoList(Op("Bool",[]))]),NoAnnoList(Tuple([Var("x"),Var("y")]))))),RDefNoArgs("constraint-error-op",RuleNoCond(NoAnnoList(Tuple([NoAnnoList(Op("OpOr",[])),Var("x"),Var("y")])),App(CallT(SVar("validate_both_sides"),[],[NoAnnoList(Op("Bool",[]))]),NoAnnoList(Tuple([Var("x"),Var("y")]))))),RDefNoArgs("constraint-error-op",RuleNoCond(NoAnnoList(Tuple([NoAnnoList(Op("OpGreaterThan",[])),Var("x"),Var("y")])),App(CallT(SVar("validate_both_sides"),[],[NoAnnoList(Op("Num",[]))]),NoAnnoList(Tuple([Var("x"),Var("y")]))))),RDefNoArgs("constraint-error-op",RuleNoCond(NoAnnoList(Tuple([NoAnnoList(Op("OpSmallerThan",[])),Var("x"),Var("y")])),App(CallT(SVar("validate_both_sides"),[],[NoAnnoList(Op("Num",[]))]),NoAnnoList(Tuple([Var("x"),Var("y")]))))),RDefNoArgs("constraint-error-op",RuleNoCond(NoAnnoList(Tuple([NoAnnoList(Op("OpEqSmallerThan",[])),Var("x"),Var("y")])),App(CallT(SVar("validate_both_sides"),[],[NoAnnoList(Op("Num",[]))]),NoAnnoList(Tuple([Var("x"),Var("y")]))))),RDefNoArgs("constraint-error-op",RuleNoCond(NoAnnoList(Tuple([NoAnnoList(Op("OpEqGreaterThan",[])),Var("x"),Var("y")])),App(CallT(SVar("validate_both_sides"),[],[NoAnnoList(Op("Num",[]))]),NoAnnoList(Tuple([Var("x"),Var("y")]))))),RDefNoArgs("constraint-error-op",Rule(As(Var("e"),NoAnnoList(Tuple([NoAnnoList(Op("OpEquals",[])),Var("x"),Var("y")]))),NoAnnoList(Tuple([Var("e"),NoAnnoList(StringQuotation1("                                                           ",[QStr("Expected the left and right hand side of == to be the same. Got "),StringEscape1("                                                                                                                           ",App(CallNoArgs(SVar("type-name")),Var("x"))),QStr(", and "),StringEscape1("                                                                                                                                                ",App(CallNoArgs(SVar("type-name")),Var("y"))),QStr(".")]))])),Not(BA(CallNoArgs(SVar("equal")),NoAnnoList(Tuple([App(CallNoArgs(SVar("type-of")),Var("x")),App(CallNoArgs(SVar("type-of")),Var("y"))])))))),RDefNoArgs("constraint-error-op",RuleNoCond(As(Var("e"),NoAnnoList(Tuple([NoAnnoList(Op("OpEquals",[])),Var("x"),Var("y")]))),App(CallT(SVar("validate_both_sides"),[],[NoAnnoList(List([NoAnnoList(Op("Num",[])),NoAnnoList(Op("String",[])),NoAnnoList(Op("Bool",[]))]))]),NoAnnoList(Tuple([Var("x"),Var("y")])))))]),Rules([RDefNoArgs("constraint-error",Rule(NoAnnoList(Op("MapReduceChain",[Var("input"),Var("map"),Var("reducer")])),Var("errors"),Seq(Assign(Var("inputtype"),App(CallNoArgs(SVar("type-of")),Var("input"))),Seq(Assign(Var("maptype"),App(CallNoArgs(SVar("type-of")),Var("map"))),Seq(Assign(Var("reducetype"),App(CallNoArgs(SVar("type-of")),Var("reducer"))),Seq(LChoice(Assign(Var("errors-input"),NoAnnoList(List([App(CallT(SVar("mrchaincheck"),[],[Var("inputtype")]),Var("input"))]))),Assign(Var("errors-input"),NoAnnoList(List([])))),Seq(LChoice(Assign(Var("errors-map"),NoAnnoList(List([App(CallT(SVar("mrchaincheck"),[],[Var("inputtype")]),Var("map"))]))),Assign(Var("errors-map"),NoAnnoList(List([])))),Seq(LChoice(Assign(Var("errors-reduce"),NoAnnoList(List([App(CallT(SVar("mrchaincheck"),[],[Var("maptype")]),Var("reducer"))]))),Assign(Var("errors-reduce"),NoAnnoList(List([])))),Seq(Assign(Var("errors"),App(CallNoArgs(SVar("conc")),NoAnnoList(Tuple([Var("errors-input"),Var("errors-map"),Var("errors-reduce")])))),Not(BA(CallNoArgs(SVar("equal")),NoAnnoList(Tuple([App(CallNoArgs(SVar("length")),Var("errors")),NoAnnoList(Int("0"))]))))))))))))),RDefT("mrchaincheck",[],[DefaultVarDec("x")],Rule(As(Var("m"),NoAnnoList(Op("MRInputSet",[Var("ref")]))),NoAnnoList(Tuple([Var("ref"),NoAnnoList(StringQuotation1("                                                   ",[QStr("Currently it not supported to continue with a stored dataset.")]))])),Seq(Assign(NoAnnoList(Op("Def",[Var("uri")])),App(CallNoArgs(SVar("index-lookup")),Var("ref"))),Not(BA(CallNoArgs(SVar("equal")),NoAnnoList(Tuple([NoAnnoList(Int("0")),App(CallNoArgs(SVar("length")),App(CallNoArgs(SVar("index-get-all")),NoAnnoList(Op("StoreDatasetHDP",[Var("uri")]))))]))))))),RDefT("mrchaincheck",[],[DefaultVarDec("inputtype")],Rule(As(Var("m"),NoAnnoList(Op("MRMapper",[NoAnnoList(Op("MapperRef",[Var("mapper")]))]))),NoAnnoList(Tuple([Var("mapper"),NoAnnoList(StringQuotation1("                                                                          ",[QStr("Wrong mapper input type: expected "),StringEscape1("                                                                                                            ",Var("expected'")),QStr(", but got "),StringEscape1("                                                                                                                                 ",Var("got'")),QStr(".")]))])),Seq(Assign(NoAnnoList(Op("Mapper",[Var("name"),NoAnnoList(Op("MapInner",[Var("key"),Var("value"),Wld]))])),App(CallNoArgs(SVar("get-node")),Var("mapper"))),Seq(Assign(Var("expectedkey"),App(CallNoArgs(SVar("type-type-of")),Var("key"))),Seq(Assign(Var("expectedvalue"),App(CallNoArgs(SVar("type-type-of")),Var("value"))),Seq(Assign(Var("expected"),NoAnnoList(Op("Type",[NoAnnoList(Op("List",[NoAnnoList(Op("TwoType",[Var("expectedkey"),Var("expectedvalue")]))])),NoAnnoList(Int("1"))]))),Seq(Not(BA(CallNoArgs(SVar("equal")),NoAnnoList(Tuple([Var("expected"),Var("inputtype")])))),Seq(Assign(Var("expected'"),App(CallNoArgs(SVar("type-name")),Var("expected"))),Assign(Var("got'"),App(CallNoArgs(SVar("type-name")),Var("inputtype"))))))))))),RDefT("mrchaincheck",[],[DefaultVarDec("inputtype")],Rule(As(Var("m"),NoAnnoList(Op("MRReducer",[NoAnnoList(Op("ReducerRef",[Var("reducer")]))]))),NoAnnoList(Tuple([Var("reducer"),NoAnnoList(StringQuotation1("                                                                               ",[QStr("Wrong reducer input type: expected "),StringEscape1("                                                                                                                  ",Var("expected'")),QStr(", but got "),StringEscape1("                                                                                                                                       ",Var("got'")),QStr(".")]))])),Seq(Assign(NoAnnoList(Op("Reducer",[Var("name"),NoAnnoList(Op("RedInner",[Var("key"),Var("value"),Wld]))])),App(CallNoArgs(SVar("get-node")),Var("reducer"))),Seq(Assign(Var("expectedkey"),App(CallNoArgs(SVar("type-type-of")),Var("key"))),Seq(Assign(Var("expectedvalue"),App(CallNoArgs(SVar("innertype")),App(CallNoArgs(SVar("type-type-of")),Var("value")))),Seq(Assign(Var("expected"),NoAnnoList(Op("Type",[NoAnnoList(Op("List",[NoAnnoList(Op("TwoType",[Var("expectedkey"),Var("expectedvalue")]))])),NoAnnoList(Int("1"))]))),Seq(Not(BA(CallNoArgs(SVar("equal")),NoAnnoList(Tuple([Var("expected"),Var("inputtype")])))),Seq(Assign(Var("expected'"),App(CallNoArgs(SVar("type-name")),Var("expected"))),Assign(Var("got'"),App(CallNoArgs(SVar("type-name")),Var("inputtype")))))))))))]),Rules([RDefNoArgs("write-to-rewriter-error",RuleNoCond(Var("w"),NoAnnoList(Tuple([Var("w"),NoAnnoList(StringQuotation1("                                        ",[QStr("Not allowed in a rewriter: write.")]))])))),RDefNoArgs("constraint-error",Rule(As(Var("r"),NoAnnoList(Op("Rewriter",[Var("t1"),Var("t2"),Var("t3"),Var("t4")]))),Var("errors"),Seq(Assign(Var("allwrites"),App(CallNoArgs(SVar("get-all-writes")),Var("r"))),Seq(Not(BA(CallNoArgs(SVar("equal")),NoAnnoList(Tuple([App(CallNoArgs(SVar("length")),Var("allwrites")),NoAnnoList(Int("0"))])))),Assign(Var("errors"),App(Call(SVar("map"),[CallNoArgs(SVar("write-to-rewriter-error"))]),Var("allwrites")))))))]),Rules([RDefNoArgs("rewriter-main-type",RuleNoCond(NoAnnoList(Op("Rewriter",[Wld,Var("x"),Wld,Wld])),App(CallNoArgs(SVar("type")),App(CallNoArgs(SVar("type-of")),Var("x"))))),RDefNoArgs("rewriter-main-type",RuleNoCond(NoAnnoList(Op("RewriterAlias",[Wld,Var("x"),Wld,Wld,Wld])),App(CallNoArgs(SVar("type")),App(CallNoArgs(SVar("type-of")),Var("x"))))),RDefNoArgs("rewriter-params",RuleNoCond(NoAnnoList(Op("Rewriter",[Wld,Wld,Var("params"),Wld])),Var("params"))),RDefNoArgs("rewriter-params",RuleNoCond(NoAnnoList(Op("RewriterAlias",[Wld,Wld,Var("params"),Wld,Wld])),Var("params"))),RDefNoArgs("rewriter-number-of-args",RuleNoCond(NoAnnoList(Op("Rewriter",[Wld,Wld,Var("params"),Wld])),App(CallNoArgs(SVar("length")),Var("params")))),RDefNoArgs("rewriter-number-of-args",RuleNoCond(NoAnnoList(Op("RewriterAlias",[Wld,Wld,Var("params"),Wld,Wld])),App(CallNoArgs(SVar("length")),Var("params")))),RDefNoArgs("constraint-error",Rule(NoAnnoList(Op("Rewrite",[Var("resource"),NoAnnoList(Op("RewriteRef",[Var("rewriter")])),Wld])),NoAnnoList(Tuple([Var("resource"),NoAnnoList(StringQuotation1("                                                                                 ",[QStr("Wrong type!")]))])),Not(BA(CallNoArgs(SVar("equal")),NoAnnoList(Tuple([App(CallNoArgs(SVar("rewriter-main-type")),App(CallNoArgs(SVar("get-node")),Var("rewriter"))),App(CallNoArgs(SVar("type")),App(CallNoArgs(SVar("type-of")),Var("resource")))])))))),RDefNoArgs("constraint-error",Rule(As(Var("r"),NoAnnoList(Op("Rewrite",[Wld,NoAnnoList(Op("RewriteRef",[Var("rewriter")])),Var("args")]))),NoAnnoList(Tuple([Var("r"),NoAnnoList(StringQuotation1("                                                                        ",[QStr("Wrong number of arguments is given, expected "),StringEscape1("                                                                                                                     ",Var("expected")),QStr(" arguments, got "),StringEscape1("                                                                                                                                               ",Var("given")),QStr(".")]))])),Seq(LChoice(Assign(NoAnnoList(Op("Params",[Var("givenargs")])),Var("args")),Assign(Var("givenargs"),NoAnnoList(List([])))),Seq(Assign(Var("given"),App(CallNoArgs(SVar("length")),Var("givenargs"))),Seq(Assign(Var("expected"),App(CallNoArgs(SVar("rewriter-number-of-args")),App(CallNoArgs(SVar("get-node")),Var("rewriter")))),Not(BA(CallNoArgs(SVar("equal")),NoAnnoList(Tuple([Var("expected"),Var("given")]))))))))),RDefNoArgs("constraint-error",Rule(NoAnnoList(Op("Rewrite",[Wld,NoAnnoList(Op("RewriteRef",[Var("rewriter")])),NoAnnoList(Op("Params",[Var("args")]))])),Var("errors"),Seq(Assign(Var("paramtypes"),App(CallNoArgs(SVar("rewriter-params")),App(CallNoArgs(SVar("get-node")),Var("rewriter")))),Seq(BA(CallNoArgs(SVar("equal")),NoAnnoList(Tuple([App(CallNoArgs(SVar("length")),Var("args")),App(CallNoArgs(SVar("length")),Var("paramtypes"))]))),Assign(Var("errors"),App(CallT(SVar("rewriter-params-typecheckhelper"),[],[Var("paramtypes")]),Var("args"))))))),RDefT("rewriter-params-typecheckhelper",[],[DefaultVarDec("x")],RuleNoCond(NoAnnoList(List([])),NoAnnoList(List([])))),RDefT("rewriter-params-typecheckhelper",[],[DefaultVarDec("paramtypes")],Rule(Var("args"),Var("errors"),Seq(Assign(NoAnnoList(ListTail([Var("p")],Var("ps"))),Var("paramtypes")),Seq(Assign(NoAnnoList(ListTail([Var("a")],Var("as"))),Var("args")),Seq(Assign(Var("errors'"),App(CallT(SVar("rewriter-params-typecheckhelper"),[],[Var("ps")]),Var("as"))),LChoice(Seq(Not(BA(CallNoArgs(SVar("equal")),NoAnnoList(Tuple([App(CallNoArgs(SVar("type")),App(CallNoArgs(SVar("type-of")),Var("p"))),App(CallNoArgs(SVar("type")),App(CallNoArgs(SVar("type-of")),Var("a")))])))),Assign(Var("errors"),App(CallNoArgs(SVar("union")),NoAnnoList(Tuple([NoAnnoList(List([NoAnnoList(Tuple([Var("a"),NoAnnoList(StringQuotation1("                                         ",[QStr("Wrong type, expected "),StringEscape1("                                                              ",App(CallNoArgs(SVar("type-of-name")),Var("p"))),QStr(", got "),StringEscape1("                                                                                      ",App(CallNoArgs(SVar("type-of-name")),Var("a"))),QStr(".")]))]))])),Var("errors'")]))))),LChoice(Seq(BA(CallNoArgs(SVar("is-dataset")),App(CallNoArgs(SVar("type-of")),Var("a"))),Assign(Var("errors"),App(CallNoArgs(SVar("union")),NoAnnoList(Tuple([NoAnnoList(List([NoAnnoList(Tuple([Var("a"),NoAnnoList(StringQuotation1("                                         ",[QStr("It is not possible (yet) to have an Hadoop iterator as non-first argument.")]))]))])),Var("errors'")]))))),Assign(Var("errors"),Var("errors'")))))))))]),Rules([RDefNoArgs("constraint-warning",Rule(As(Var("r"),NoAnnoList(Op("DatasetRef",[Var("name")]))),Var("errors"),Seq(BA(CallNoArgs(SVar("is-type-iterator")),App(CallNoArgs(SVar("type-type-of")),Var("r"))),Seq(LChoice(Seq(Assign(Var("errorsnode"),App(CallNoArgs(SVar("index-get-value")),NoAnnoList(Op("CachedError",[NoAnnoList(List([Var("name")])),NoAnnoList(Tuple([]))])))),Assign(Var("errors"),NoAnnoList(Tuple([Var("errorsnode"),NoAnnoList(StringQuotation1("                                         ",[QStr("Iterator "),StringEscape1("                                                  ",Var("name")),QStr(" is already used. Using it again probably means the set is empty!")]))])))),Assign(Var("errors"),NoAnnoList(Tuple([])))),Seq(BA(CallNoArgs(SVar("put-node")),NoAnnoList(Op("CachedError",[NoAnnoList(List([Var("name")])),Var("r")]))),Not(BA(CallNoArgs(SVar("equal")),NoAnnoList(Tuple([NoAnnoList(Tuple([])),Var("errors")])))))))))]),Rules([RDefNoArgs("write-error-rewrite",RuleNoCond(Var("e"),NoAnnoList(Tuple([Var("e"),NoAnnoList(StringQuotation1("                                    ",[QStr("All writes should should be of the same type.")]))])))),RDefNoArgs("write-value",RuleNoCond(NoAnnoList(Op("write",[Var("k"),Var("v")])),Var("v"))),RDefNoArgs("constraint-error",RuleNoCond(As(Var("m"),NoAnnoList(Op("Mapper",[Wld,Wld]))),RootApp(CallNoArgs(SVar("write-all-of-same-type-errors"))))),RDefNoArgs("constraint-error",RuleNoCond(As(Var("r"),NoAnnoList(Op("Reducer",[Wld,Wld]))),RootApp(CallNoArgs(SVar("write-all-of-same-type-errors"))))),RDefNoArgs("valid_writetype",Rule(Var("w"),Var("w"),BA(CallNoArgs(SVar("type-of")),Var("w")))),RDefNoArgs("write-all-of-same-type-errors",Rule(Var("t"),Var("errors"),Seq(Assign(Var("all-writes"),App(Call(SVar("filter"),[CallNoArgs(SVar("valid_writetype"))]),App(CallNoArgs(SVar("get-all-writes")),Var("t")))),Seq(Not(BA(CallNoArgs(SVar("list-eq")),App(Call(SVar("map"),[CallNoArgs(SVar("type"))]),App(Call(SVar("map"),[CallNoArgs(SVar("type-of"))]),Var("all-writes"))))),Seq(Assign(Var("errors"),App(Call(SVar("map"),[CallNoArgs(SVar("write-error-rewrite"))]),Var("all-writes"))),BA(CallNoArgs(SVar("gt")),NoAnnoList(Tuple([App(CallNoArgs(SVar("length")),Var("errors")),NoAnnoList(Int("0"))])))))))),RDefNoArgs("constraint-error",RuleNoCond(As(Var("m"),NoAnnoList(Op("Mapper",[Wld,Wld]))),App(CallNoArgs(SVar("check-write-statements")),Var("m")))),RDefNoArgs("constraint-error",RuleNoCond(As(Var("r"),NoAnnoList(Op("Reducer",[Wld,Wld]))),App(CallNoArgs(SVar("check-write-statements")),Var("r")))),RDefNoArgs("check-write-statements",Rule(Var("t"),NoAnnoList(Tuple([Var("t"),NoAnnoList(StringQuotation1("                                       ",[QStr("Each map and reduce should have at least one 1 write-statement.")]))])),BA(CallNoArgs(SVar("equal")),NoAnnoList(Tuple([App(CallNoArgs(SVar("length")),App(CallNoArgs(SVar("get-all-writes")),Var("t"))),NoAnnoList(Int("0"))]))))),RDefNoArgs("constraint-error",Rule(NoAnnoList(Op("write",[Var("k"),Var("v")])),Var("errors"),LChoice(Seq(BA(CallNoArgs(SVar("is-type-iterator")),App(CallNoArgs(SVar("type-type-of")),Var("k"))),Seq(BA(CallNoArgs(SVar("is-type-iterator")),App(CallNoArgs(SVar("type-type-of")),Var("v"))),Assign(Var("errors"),NoAnnoList(List([NoAnnoList(Tuple([Var("k"),NoAnnoList(StringQuotation1("                                 ",[QStr("Write statements can not have iterators as key.")]))])),NoAnnoList(Tuple([Var("v"),NoAnnoList(StringQuotation1("                                 ",[QStr("Write statements can not have iterators as value.")]))]))]))))),LChoice(Seq(BA(CallNoArgs(SVar("is-type-iterator")),App(CallNoArgs(SVar("type-type-of")),Var("k"))),Assign(Var("errors"),NoAnnoList(Tuple([Var("k"),NoAnnoList(StringQuotation1("                                ",[QStr("Write statements can not have iterators as key.")]))])))),Seq(BA(CallNoArgs(SVar("is-type-iterator")),App(CallNoArgs(SVar("type-type-of")),Var("v"))),Assign(Var("errors"),NoAnnoList(Tuple([Var("v"),NoAnnoList(StringQuotation1("                                ",[QStr("Write statements can not have iterators as value.")]))])))))))),RDefNoArgs("constraint-error",Rule(As(Var("r"),NoAnnoList(Op("Mapper",[Var("name"),NoAnnoList(Op("MapInner",[Var("key"),Var("value"),Var("block")]))]))),NoAnnoList(Tuple([Var("value"),NoAnnoList(StringQuotation1("                                                                               ",[QStr("A mapper can never have an iterator as input!")]))])),BA(CallNoArgs(SVar("is-type-iterator")),App(CallNoArgs(SVar("type-type-of")),Var("value"))))),RDefNoArgs("constraint-error",Rule(As(Var("r"),NoAnnoList(Op("Mapper",[Var("name"),NoAnnoList(Op("RedInner",[Var("key"),Var("value"),Var("block")]))]))),NoAnnoList(Tuple([Var("value"),NoAnnoList(StringQuotation1("                                                                               ",[QStr("A mapper can never have an iterator as input!")]))])),BA(CallNoArgs(SVar("is-type-iterator")),App(CallNoArgs(SVar("type-type-of")),Var("value")))))]),Rules([RDefNoArgs("constraint-error",Rule(As(Var("r"),NoAnnoList(Op("ReduceIterator",[Var("type"),Wld]))),NoAnnoList(Tuple([Var("r"),NoAnnoList(StringQuotation1("                                                         ",[QStr("An iterator is expected, got "),StringEscape1("                                                                                      ",App(CallNoArgs(SVar("type-name")),App(CallNoArgs(SVar("type-of")),Var("type"))))]))])),Not(BA(CallNoArgs(SVar("is-type-iterator")),App(CallNoArgs(SVar("type-of")),Var("type"))))))]),Rules([RDefNoArgs("constraint-error",Rule(NoAnnoList(Op("If",[Var("expr"),Wld,Wld])),NoAnnoList(Tuple([Var("expr"),NoAnnoList(StringQuotation1("                                                 ",[QStr("A boolean value was expected, got "),StringEscape1("                                                                                   ",App(CallNoArgs(SVar("type-name")),App(CallNoArgs(SVar("type-type-of")),Var("expr")))),QStr(".")]))])),Not(BA(CallNoArgs(SVar("equal")),NoAnnoList(Tuple([NoAnnoList(Op("Bool",[])),App(CallNoArgs(SVar("type-type-of")),Var("expr"))]))))))]),Rules([RDefNoArgs("constraint-error",RuleNoCond(NoAnnoList(Op("ExpDictaccess",[Var("x")])),NoAnnoList(Tuple([Var("x"),NoAnnoList(StringQuotation1("                                                ",[QStr("It is not allowed to acces a dict or list directly. You can get values from this element by using a loop-construction.")]))])))),RDefT("dict-item-value-to-error",[],[DefaultVarDec("expectedtype")],RuleNoCond(NoAnnoList(Op("DictItem",[Wld,Var("v")])),NoAnnoList(Tuple([Var("v"),NoAnnoList(StringQuotation1("                                                                     ",[QStr("Expected "),StringEscape1("                                                                              ",App(CallNoArgs(SVar("type-of-name")),Var("expectedtype"))),QStr(", got "),StringEscape1("                                                                                                                 ",App(CallNoArgs(SVar("type-of-name")),Var("v")))]))])))),RDefT("list-item-value-to-error",[],[DefaultVarDec("expectedtype")],RuleNoCond(Var("v"),NoAnnoList(Tuple([Var("v"),NoAnnoList(StringQuotation1("                                                                     ",[QStr("Expected "),StringEscape1("                                                                              ",App(CallNoArgs(SVar("type-of-name")),Var("expectedtype"))),QStr(", got "),StringEscape1("                                                                                                                 ",App(CallNoArgs(SVar("type-of-name")),Var("v")))]))])))),RDefNoArgs("constraint-error",Rule(NoAnnoList(Op("ListDictSetItem",[As(Var("i"),NoAnnoList(Op("DictAccess",[Var("k"),Var("v")]))),Wld])),NoAnnoList(Tuple([Var("i"),NoAnnoList(StringQuotation1("	                                                                  ",[QStr("Could not set or overwrite values of a list.")]))])),Assign(NoAnnoList(Op("List",[Var("x")])),App(CallNoArgs(SVar("type-type-of")),Var("k"))))),RDefNoArgs("constraint-error",Rule(NoAnnoList(Op("DictItem",[Var("k"),Var("v")])),NoAnnoList(Tuple([Var("k"),NoAnnoList(StringQuotation1("	                                          ",[QStr("Dictionairy keys should be of type String, got "),StringEscape1("	                                                                                         ",App(CallNoArgs(SVar("type-of-name")),Var("k")))]))])),Not(BA(CallT(SVar("typecheck"),[],[NoAnnoList(Op("String",[]))]),Var("k"))))),RDefNoArgs("constraint-error",Rule(NoAnnoList(Op("DictAccess",[Var("listdict"),Wld])),NoAnnoList(Tuple([Var("listdict"),NoAnnoList(StringQuotation1("                                                              ",[QStr("A dictonairy or list was expected, got "),StringEscape1("                                                                                                     ",App(CallNoArgs(SVar("type-of-name")),Var("listdict"))),QStr(".")]))])),Not(LChoice(Assign(NoAnnoList(Op("Dict",[Var("x")])),App(CallNoArgs(SVar("type-type-of")),Var("listdict"))),Assign(NoAnnoList(Op("List",[Var("x")])),App(CallNoArgs(SVar("type-type-of")),Var("listdict"))))))),RDefNoArgs("constraint-error",Rule(NoAnnoList(Op("DictAccess",[Var("dict"),Var("k")])),NoAnnoList(Tuple([Var("k"),NoAnnoList(StringQuotation1("                                                   ",[QStr("Dictionairy keys are always of type String, got "),StringEscape1("                                                                                                   ",App(CallNoArgs(SVar("type-of-name")),Var("k")))]))])),Seq(Assign(NoAnnoList(Op("Dict",[Var("x")])),App(CallNoArgs(SVar("type-type-of")),Var("dict"))),Not(BA(CallT(SVar("typecheck"),[],[NoAnnoList(Op("String",[]))]),Var("k")))))),RDefNoArgs("constraint-error",Rule(NoAnnoList(Op("Dict",[Var("dicttype"),Var("items")])),App(Call(SVar("map"),[CallT(SVar("dict-item-value-to-error"),[],[Var("dicttype")])]),Var("erroritems")),Assign(Var("erroritems"),App(Call(SVar("filter"),[Not(CallT(SVar("typecheck"),[],[App(CallNoArgs(SVar("type-of")),Var("dicttype"))]))]),Var("items"))))),RDefNoArgs("constraint-error",Rule(NoAnnoList(Op("List",[Var("listtype"),Var("items")])),App(Call(SVar("map"),[CallT(SVar("list-item-value-to-error"),[],[Var("listtype")])]),Var("erroritems")),Assign(Var("erroritems"),App(Call(SVar("filter"),[Not(CallT(SVar("typecheck"),[],[App(CallNoArgs(SVar("type-of")),Var("listtype"))]))]),Var("items"))))),RDefNoArgs("constraint-error",Rule(NoAnnoList(Op("ListAddItem",[Var("list"),Wld])),NoAnnoList(Tuple([Var("list"),NoAnnoList(StringQuotation1("                                                       ",[QStr("A list was exptected, got "),StringEscape1("                                                                                 ",App(CallNoArgs(SVar("type-of-name")),Var("list")))]))])),Not(Assign(NoAnnoList(Op("List",[Var("x")])),App(CallNoArgs(SVar("type-type-of")),Var("list")))))),RDefNoArgs("constraint-error",Rule(NoAnnoList(Op("ListAddItem",[Var("list"),Var("expr")])),NoAnnoList(Tuple([Var("expr"),NoAnnoList(StringQuotation1("                                                          ",[QStr("Appending wrong type to list.")]))])),Seq(Assign(NoAnnoList(Op("List",[Var("x")])),App(CallNoArgs(SVar("type-type-of")),Var("list"))),Not(BA(CallT(SVar("typecheck"),[],[Var("x")]),Var("expr"))))))]),Rules([RDefNoArgs("constraint-error",Rule(NoAnnoList(Op("ForloopSet",[Wld,Var("l"),Wld])),NoAnnoList(Tuple([Var("l"),NoAnnoList(StringQuotation1("                                                   ",[QStr("A list or iterator was expected.")]))])),Seq(Assign(Var("l'"),App(CallNoArgs(SVar("type-type-of")),Var("l"))),Not(LChoice(BA(CallNoArgs(SVar("is-type-list")),Var("l'")),BA(CallNoArgs(SVar("is-type-iterator")),Var("l'"))))))),RDefNoArgs("constraint-error",Rule(NoAnnoList(Op("ForloopDict",[Wld,Var("k"),Var("v"),Wld])),NoAnnoList(Tuple([Var("v"),NoAnnoList(StringQuotation1("                                                       ",[QStr("A dict was expected.")]))])),Not(BA(CallNoArgs(SVar("is-type-dict")),App(CallNoArgs(SVar("type-type-of")),Var("v")))))),RDefNoArgs("extra-index-hook",Rule(As(Var("r"),NoAnnoList(Op("RewriterAlias",[Wld,Var("p"),Var("ps"),Wld,Wld]))),RootApp(Fail),Seq(Assign(NoAnnoList(Op("RewriterParameter",[Wld,AnnoList(Var("pname"),[NoAnnoList(ListTail([Var("ns")],Var("path")))])])),Var("p")),Seq(BA(CallNoArgs(SVar("put-node")),NoAnnoList(Op("Use",[NoAnnoList(ListTail([Var("ns")],Var("path")))]))),BA(Call(SVar("map"),[CallNoArgs(SVar("fake-use"))]),Var("ps")))))),RDefNoArgs("fake-use",RuleNoCond(NoAnnoList(Op("Parameter",[Wld,AnnoList(Var("pname"),[NoAnnoList(ListTail([Var("ns")],Var("path")))])])),App(CallNoArgs(SVar("put-node")),NoAnnoList(Op("Use",[NoAnnoList(ListTail([Var("ns")],Var("path")))]))))),RDefNoArgs("constraint-note",RuleNoCond(As(Var("r"),NoAnnoList(Op("RewriterAlias",[Wld,Wld,Wld,Wld,Wld]))),NoAnnoList(Tuple([Var("r"),NoAnnoList(StringQuotation1("          ",[QStr("Rewriter aliases let you call external commands. The input and\n    output types are not checked in any form at editing level.\n    \n    See external documentation for proper use.\n    \n    If it passes the compile source to jar phase, the methods will work,\n    at least, it is compatible with the Hadooplang types..\n    \n    ** Use at your own risk **\n    \n    ")]))]))))]),Rules([RDefT("validate_both_sides",[],[DefaultVarDec("comptype")],Rule(NoAnnoList(Tuple([Var("x"),Var("y")])),App(CallT(SVar("validate_both_sides"),[],[NoAnnoList(List([Var("comptype")]))]),NoAnnoList(Tuple([Var("x"),Var("y")]))),Not(BA(CallNoArgs(SVar("length")),Var("comptype"))))),RDefT("validate_both_sides",[],[DefaultVarDec("comptypes")],Rule(NoAnnoList(Tuple([Var("x"),Var("y")])),Var("errors"),Seq(BA(CallNoArgs(SVar("length")),Var("comptypes")),Seq(Assign(Var("x'"),App(CallNoArgs(SVar("type-type-of")),Var("x"))),Seq(Not(BA(Call(SVar("fetch"),[Match(Var("x'"))]),Var("comptypes"))),Seq(Assign(Var("y'"),App(CallNoArgs(SVar("type-type-of")),Var("y"))),Seq(Not(BA(Call(SVar("fetch"),[Match(Var("y'"))]),Var("comptypes"))),Assign(Var("errors"),NoAnnoList(List([NoAnnoList(Tuple([Var("x"),NoAnnoList(StringQuotation1("                      ",[QStr("Wrong type; expected "),StringEscape1("                                           ",App(CallNoArgs(SVar("type-name")),Var("comptypes"))),QStr(" got "),StringEscape1("                                                                       ",App(CallNoArgs(SVar("type-of-name")),Var("x"))),QStr(".")]))])),NoAnnoList(Tuple([Var("y"),NoAnnoList(StringQuotation1("                      ",[QStr("Wrong type; expected "),StringEscape1("                                           ",App(CallNoArgs(SVar("type-name")),Var("comptypes"))),QStr(" got "),StringEscape1("                                                                       ",App(CallNoArgs(SVar("type-of-name")),Var("y"))),QStr(".")]))]))])))))))))),RDefT("validate_both_sides",[],[DefaultVarDec("comptypes")],Rule(NoAnnoList(Tuple([Var("x"),Wld])),NoAnnoList(List([Var("errors")])),Seq(BA(CallNoArgs(SVar("length")),Var("comptypes")),Seq(Assign(Var("x'"),App(CallNoArgs(SVar("type-type-of")),Var("x"))),Seq(Not(BA(Call(SVar("fetch"),[Match(Var("x'"))]),Var("comptypes"))),Assign(Var("errors"),NoAnnoList(Tuple([Var("x"),NoAnnoList(StringQuotation1("                            ",[QStr("Wrong type; expected "),StringEscape1("                                                 ",App(CallNoArgs(SVar("type-name")),Var("comptypes"))),QStr(", got "),StringEscape1("                                                                              ",App(CallNoArgs(SVar("type-of-name")),Var("x"))),QStr(".")]))])))))))),RDefT("validate_both_sides",[],[DefaultVarDec("comptypes")],Rule(NoAnnoList(Tuple([Wld,Var("y")])),NoAnnoList(List([Var("errors")])),Seq(BA(CallNoArgs(SVar("length")),Var("comptypes")),Seq(Assign(Var("y'"),App(CallNoArgs(SVar("type-type-of")),Var("y"))),Seq(Not(BA(Call(SVar("fetch"),[Match(Var("y'"))]),Var("comptypes"))),Assign(Var("errors"),NoAnnoList(Tuple([Var("y"),NoAnnoList(StringQuotation1("                            ",[QStr("Wrong type; expected "),StringEscape1("                                                 ",App(CallNoArgs(SVar("type-name")),Var("comptypes"))),QStr(", got "),StringEscape1("                                                                              ",App(CallNoArgs(SVar("type-of-name")),Var("y"))),QStr(".")]))]))))))))])])